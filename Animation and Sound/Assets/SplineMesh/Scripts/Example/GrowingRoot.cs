using System.Collections;
using System.Collections.Generic;
#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEngine;

namespace SplineMesh {
    /// <summary>
    /// Example of component to show the deformation of the mesh on a changing
    /// interval and changing spline nodes.
    /// 
    /// In this example, as the MeshBender is working on spline space, it will update
    /// the mesh if one of the curve change. Each change make the MeshBender "dirty" and
    /// it will compute the mesh only once on it's next update call.
    /// 
    /// This component is only for demo purpose and is not intended to be used as-is.
    /// </summary>
    ///
    [ExecuteInEditMode]
    [RequireComponent(typeof(Spline))]
    public class GrowingRoot : MonoBehaviour {

        private static float MIN_GROWTH = 0.001f;

        private GameObject generated;
        private Spline spline;

        private MeshBender meshBender;
        private Coroutine _animation;

        public Mesh mesh;
        public Material material;
        public Vector3 rotation;
        public Vector3 scale;

        public float startScale = 1;

        [Range(0.001f, 1f)]
        public float rate = MIN_GROWTH;
        private float _prevRate = MIN_GROWTH;

        public float autoDurationInSeconds = 5;

        private void OnEnable() {
            Init();
        }

        private void OnValidate() {
            Init();
        }

        IEnumerator DoGrow()
        {
            while(rate < 1)
            {
                Contort();
                rate += Time.deltaTime / autoDurationInSeconds;
                rate = Mathf.Clamp(rate, MIN_GROWTH, 1.0f);
                yield return null;
            }
        }

        IEnumerator DoShrink()
        {
            while (rate > MIN_GROWTH)
            {
                rate -= Time.deltaTime / autoDurationInSeconds;
                rate = Mathf.Clamp(rate, MIN_GROWTH, 1.0f);
                yield return null;
            }
        }

        private void Update()
        {
            if(!Mathf.Approximately(rate, _prevRate))
            {
                Contort();
                _prevRate = rate;
            }
        }

        public void Grow()
        {
            if(_animation != null)
            {
                StopCoroutine(_animation);
                _animation = null;
            }

            _animation = StartCoroutine(DoGrow());
        }

        public void Shrink()
        {
            if (_animation != null)
            {
                StopCoroutine(_animation);
                _animation = null;
            }
            _animation = StartCoroutine(DoShrink());
        }

        private void Contort() {
            float nodeDistance = 0;
            int i = 0;
            foreach (var n in spline.nodes) {
                float nodeDistanceRate = nodeDistance / spline.Length;
                float nodeScale = startScale * (rate - nodeDistanceRate);
                n.Scale = new Vector2(nodeScale, nodeScale);
                if (i < spline.curves.Count) {
                    nodeDistance += spline.curves[i++].Length;
                }
            }

            if (generated != null) {
                meshBender.SetInterval(spline, 0, spline.Length * rate);
                meshBender.ComputeIfNeeded();
            }
        }

        private void Init() {
            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject,
                typeof(MeshFilter),
                typeof(MeshRenderer),
                typeof(MeshBender));

            generated.GetComponent<MeshRenderer>().material = material;

            meshBender = generated.GetComponent<MeshBender>();
            spline = GetComponent<Spline>();

            meshBender.Source = SourceMesh.Build(mesh)
                .Rotate(Quaternion.Euler(rotation))
                .Scale(scale);
            meshBender.Mode = MeshBender.FillingMode.StretchToInterval;
            meshBender.SetInterval(spline, 0, 0.01f);
        }
    }

#if UNITY_EDITOR

    [CustomEditor(typeof(GrowingRoot))]
    public class ExampleGrowingRootEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            GrowingRoot gr = (GrowingRoot)target;

            if(GUILayout.Button("Grow"))
            {
                gr.Grow();
            }

            if (GUILayout.Button("Shrink"))
            {
                gr.Shrink();
            }

            DrawDefaultInspector();
        }
    }

#endif

}
